/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package crypto_scheme;

import java.math.BigInteger;
import java.util.Random;

/**
 *
 * @author raisaro
 * @modification kasaquan
 */
public class Scheme {
    
    private boolean canEncrypt; // Whether encryption can take place.
    private boolean canDecrypt; // Whether decryption can take place.
    private BigInteger x;       // Private Key a random integer â‚¬ [1,n^2/2] 
    private BigInteger g;       // Encryption base.
    private BigInteger h;       // Encryption base.
    private BigInteger n;       // Public key.
    private BigInteger nsqr;    // The value n^2 (n squared).
    private Random prng;        // Random number generator.
    
    public Scheme(BigInteger N, BigInteger G, BigInteger H, BigInteger X){
        canEncrypt = true;
        canDecrypt = true;
        n = N;
        g = G;
        h = H;
        x = X;
        nsqr = n.multiply(n);
        prng = new Random( System.currentTimeMillis() );
    }
    
    
    public Scheme(BigInteger N, BigInteger G, BigInteger H){
        canEncrypt = true;
        canDecrypt = false;
        n = N;
        g = G;
        h = H;
        nsqr = n.multiply(n);
        prng = new Random( System.currentTimeMillis() );
    }
    
    
    /**
     * Encrypts the given plaintext to produce ciphertext.
     *
     * @param plain The plaintext.
     *
     * @return The encrypted value of the plaintext, modulo n^2.
     *
     * @exception CryptoException If the encryption cannot be performed or
     *                            there is an error while encrypting
     *                            the plaintext.
     */
    
    public BigInteger[] encrypt( BigInteger plain ) throws CryptoException{
        
        BigInteger[] cipher = new BigInteger[2];
        BigInteger cipherA; // The ciphertext A.
        BigInteger cipherB; // The ciphertext B.
        long rand;         // Value generated by PRNG.
        BigInteger r;      // Random value used to hide plaintext.

	if( !canEncrypt ) {
	    throw new CryptoException( "Cannot encrypt value " +
	        plain + " because no public key was defined." );
	}

	do{
//        rand = Math.abs( prng.nextLong() ) % (n.divide(BigInteger.valueOf(4))).longValue();
//	r = BigInteger.valueOf( rand );
        
        r = new BigInteger(1024, new Random());
        r = r.mod(n.divide(BigInteger.valueOf(4)));
        r = r.add(BigInteger.ONE);
        
//        System.out.println("r = " + r);
        
        cipherA = g.modPow( r, nsqr );
//        System.out.println("gcd = " + gcd(cipherA.longValue(),nsqr.longValue()));
        
        }while((gcd(cipherA.longValue(),nsqr.longValue()) != 1)||(r.equals(BigInteger.ZERO)));
        
        
        //BigInteger hPOWr = h.pow(r.intValue());
        //cipherB = (hPOWr.multiply((plain.multiply(n)).add(BigInteger.ONE))).mod(nsqr);
        
        cipherB = (h.modPow(r, nsqr)).multiply(((plain.multiply(n).mod(nsqr)).add(BigInteger.ONE)).mod(nsqr)).mod(nsqr);
        
        cipher[0] = cipherA;
        cipher[1] = cipherB; 

	return cipher;

    }
    
    /**
     * Decrypts the given ciphertext, which was previously encrypted using
     * the public key given to this instance of the class. This method will
     * throw an exception if no decryption keys were defined.
     *
     * @param cipher The ciphertext.
     *
     * @return The decrypted value of the plaintext, modulo n.
     *
     * @exception CryptoException If the decryption fails.
     */

    public BigInteger decrypt( BigInteger[] cipher ) throws CryptoException {

    	BigInteger plain; // The plaintext.
        BigInteger cipherA = cipher[0];
        BigInteger cipherB = cipher[1];
        BigInteger Ainv;   // Intermediate result during decryption.

	if( !canDecrypt ) {
	    throw new CryptoException( "Cannot decrypt value " +
	        cipherB.longValue() + " because no private key was defined." );
	}
        
	Ainv = (cipherA.modPow(x,nsqr)).modInverse(nsqr);
        
        plain = (((cipherB.multiply(Ainv).mod(nsqr)).subtract(BigInteger.ONE)).mod(nsqr)).divide(n);
        

	return plain;

    }
    
    /**
     * Partially Decrypts the given ciphertext, which was previously encrypted using
     * the public key given to this instance of the class. This method will
     * throw an exception if no decryption keys were defined. The private key used
     * must be part of the original private key  
     * @param cipher
     * @param x1
     * @return The modified cipher text which can be finally decrypted by the other
     * part of the original private key
     * @throws CryptoException 
     * won't be used here
     */
    public BigInteger[] proxyDecription( BigInteger[] cipher) throws CryptoException{
        
        BigInteger cipherA = cipher[0];
        BigInteger cipherB = cipher[1];
        BigInteger[] new_cipher = new BigInteger[2];
        BigInteger new_cipherB;
        BigInteger Ainv;
        
        if( !canDecrypt ) {
	    throw new CryptoException( "Cannot decrypt value " +
	        cipherB.longValue() + " because no private key was defined." );
	}
        
        Ainv = (cipherA.modPow(x,nsqr)).modInverse(nsqr);
        new_cipherB = (cipherB.multiply(Ainv)).mod(nsqr);
        
        new_cipher[0] = cipherA;
        new_cipher[1] = new_cipherB;
       
        return new_cipher;
    }
   
    /**
     * @author kasaquan
     * homomorphic property
     * multiply ciphertexts to get plaintext added*/
    
    public BigInteger[] homo_add(BigInteger[] cipher1, BigInteger[] cipher2){
    	BigInteger cipher1A = cipher1[0];
    	BigInteger cipher1B = cipher1[1];
    	BigInteger cipher2A = cipher2[0];
    	BigInteger cipher2B = cipher2[1];
    	BigInteger[] new_cipher = new BigInteger[2];
    	
    	new_cipher[0]=cipher1A.multiply(cipher2A).mod(nsqr);
    	new_cipher[1]=cipher1B.multiply(cipher2B).mod(nsqr);
    	return new_cipher;
    }
    
    public BigInteger[] homo_minus(BigInteger[] cipher1, BigInteger[] cipher2) throws CryptoException{
    	BigInteger[] cipherB = {cipher2[0].modInverse(nsqr),cipher2[1].modInverse(nsqr)};
    	return this.homo_add(cipher1, cipherB);
    }
    /**
     * An encrypted plaintext raised to a constant decrypts to the product of the plaintext and the constant*/
    
    public BigInteger[] homo_multi(BigInteger[] cipher,BigInteger c)
    {
    	BigInteger[] new_cipher =  new BigInteger[2];
    	new_cipher[0] = cipher[0].modPow(c, nsqr);
    	new_cipher[1] = cipher[1].modPow(c, nsqr);
    	return new_cipher;
 	
    }
    
    
    /**
     * Computes the least common multiple of two numbers.
     *
     * @param first First number.
     * @param second Second number.
     *
     * @return LCM of the two numbers.
     */
    
    private long lcm( long first, long second ) {

	return  first * ( second / gcd( first, second ) );

    }

    /**
     * Computes the least common multiple of two numbers.
     * @param first First number.
     * @param second Second number.
     *
     * @return LCM of the two numbers.
     */

    private BigInteger lcm( BigInteger first, BigInteger second ) {

	return  first.multiply( second.divide( first.gcd( second ) ) );

    }

    /**
     * Computes the greatest common denominator of two numbers.
     *
     * @param first First number.
     * @param second Second number.
     *
     * @return GCD of the two numbers.
     */

    private long gcd( long first, long second ) {

	return  first % second == 0 ? second : gcd( second, first % second );

    }
    
}

